/*
 *	test_scalars.c
 *
 * 	Copyright 2006 Johan de Jong
 *
 *	This file is part of Frobenius
 *
 *	Frobenius is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation; either version 2 of the License, or
 *	(at your option) any later version.
 *
 *	Frobenius is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with Frobenius; if not, write to the Free Software Foundation, 
 *	Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 *
 *									*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "data.h"
#include "scalar.h"
#include "pol.h"
#include "helper.h"
#include "compute.h"
#include "grobner.h"

static struct polynomial make_initial_pol(unsigned int degree)
{
	unsigned int a1, a2, a3, a4;
	int c;
	struct polynomial uit;
	struct term *uitterm;
	struct term **ptrterm;
	uitterm = NULL;
	uit.degree = degree;
	uit.leading = NULL;

	if (!count_sum(degree)) {
		printf("No monomials of degree %d! Stop.\n", degree);
		exit(1);
	}

	for (a1 = 0; (d1*a1 <= degree);a1++) {
	  for (a2 = 0; (d1*a1 + d2*a2 <= degree);a2++) {
	    for (a3 = 0; (d1*a1 + d2*a2 + d3*a3 <= degree);a3++) {
	      if ((degree - (a1*d1 + a2*d2 + a3*d3)) % d4 == 0) {
		a4 = (degree - (a1*d1 + a2*d2 + a3*d3))/d4;
		/* Dummy input at first. */
		c = 0;
		/* Create the new term to be put in. */
		make_term(&uitterm);
		uitterm->n1 = a1;
		uitterm->n2 = a2;
		uitterm->n3 = a3;
		uitterm->n4 = a4;
		uitterm->c = c;
		ptrterm = &(uit.leading);
		while ((*ptrterm) && (kleiner(uitterm, *ptrterm) == KLEINER)) {
			ptrterm = &((*ptrterm)->next);
		}
		uitterm->next = *ptrterm;
		*ptrterm = uitterm;
		uitterm = NULL;
	      }
	    }
	  }
	}
	return(uit);
}

int next_pol(struct polynomial P)
{
	struct term *t;
	
	t = P.leading;

	while ((t) && (t->c == p-1)) {
		t->c = 0;
		t = t->next;
	}
	if (!t) return(0);
	t->c = 1;
	return(1);
}

int is_OK(struct polynomial P)
{
	struct term *t;
	unsigned int s1 = 1, s2 = 1, s3 = 1, s4 = 1;

	t = P.leading;

	if (!t->next) {
		if (t->n1 + t->n2 + t->n3 + t->n4 > 1) return 0;
		return 1;
	}

	while (t) {
		if (t->n1 == 0) s1 = 0;
		if (t->n2 == 0) s2 = 0;
		if (t->n3 == 0) s3 = 0;
		if (t->n4 == 0) s4 = 0;
		t = t->next;
	}

	if ((s1) || (s2) || (s3) || (s4)) return 0;
	return 1;
}

int is_AB(struct polynomial A, struct polynomial B)
{
	if (deelbaar(A.leading, B.leading)) return(0);

	return is_OK(B);
}

int main()
{
	int a, b, s, n, i;
	struct polynomial f, g, A, B, AA, BB;
	f.leading = NULL;
	g.leading = NULL;
	g.degree = 0;
	A.leading = NULL;
	B.leading = NULL;
	AA.leading = NULL;
	BB.leading = NULL;

	set_seed(0);

	f = make_random(d, 0);

	printf("The polynomial is: ");
	print_pol(f);

	n = 0;
	a = 1;
	while (a < d) {
		while (!count_sum(a)) a++;
		A = make_initial_pol(a);
		while (next_pol(A)) {
			AA = copy_pol(A);
			clean_pol(&AA);
			if (is_OK(AA)) n++;
			free_tail(AA.leading);
		}
		free_tail(A.leading);
		a++;
	}
	printf("Total %d: ", n);
	fflush(stdout);

	n = n / 100;
	i = 0;
	a = 1;
	while (a < d) {
		while (!count_sum(a)) a++;
		A = make_initial_pol(a);
		while (next_pol(A)) {
			AA = copy_pol(A);
			clean_pol(&AA);
			if (is_OK(AA)) {
				i++;
				if (i % n == 0) {
					printf("%d ", i);
					fflush(stdout);
				}
				b = a;
				while (b < d) {
					while (!count_sum(b)) b++;
					B = make_initial_pol(b);
					while (next_pol(B)) {
						BB = copy_pol(B);
						clean_pol(&BB);
						if (is_AB(AA, BB)) {
							s = setup(AA, BB, f, 1);
							if (s > 1) {
								s = setup(AA, BB, g, 1);
								if (s == 2) {
									printf("\nLook at the ideal generated by: \n");
									print_pol(AA);
									print_pol(BB);
									deallocate_GVMnewMMold();
									free_reserves();
									exit(1);
								}
							}
						}
						free_tail(BB.leading);
					}
					free_tail(B.leading);
					b++;
				}
			}
			free_tail(AA.leading);
		}
		free_tail(A.leading);
		a++;
	}
	deallocate_GVMnewMMold();
	free_reserves();
	printf("\n");
	exit(0);
}
